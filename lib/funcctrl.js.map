{"version":3,"sources":["../src/funcctrl.ts"],"names":["once","f","run","error","ret","p","call","e","merge","argv","undefined","queue","max","wait","next","length","shift","getRunStatus","Promise","r","push","get","Array","isArray","map","ignore","end","getEndFunc","getNextParam","setNextParam","exec","f1","f2"],"mappings":"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","sourcesContent":["/** 封装成只会执行一次的函数，封装后函数，只会返回第一次执行时得到的结果(包括抛出的错误) */\nexport function once<T, F, R>(f: (this: T, ...p: F[]) => R): (this: any, ...p: any[]) => R | undefined {\n\tlet run = false;\n\tlet error = false;\n\tlet ret: R;\n\treturn function(this: T, ...p: F[]): R {\n\t\tif (run) {\n\t\t\tif (error) { throw ret; }\n\t\t\treturn ret;\n\t\t}\n\t\trun = true;\n\t\ttry {\n\t\t\treturn ret = f.call(this, ...p);\n\t\t} catch(e) {\n\t\t\terror = true;\n\t\t\tret = e;\n\t\t\tthrow ret;\n\t\t}\n\t}\n}\n/** 封装成合并执行的函数，封装后函数永远返回Promise，上次执行时得到的Promise未结束前，返回的将会是同一个Promise */\nexport function merge<T, P extends any[], R>(f: (this: T, ...argv: P) => R | Promise<R>): (this: T, ...argv: P) => Promise<R | undefined> {\n\tlet ret: Promise<R> | R | undefined;\n\treturn async function (this: T, ...argv: P): Promise<R | undefined> {\n\t\tif (ret) { return ret; }\n\t\ttry {\n\t\t\tret = f.call(this, ...argv);\n\t\t\treturn await ret;\n\t\t} finally {\n\t\t\tret = undefined;\n\t\t}\n\t}\n}\n/** 封装成执行队列，封装后函数永远返回Promise，确保同时执行的函数不超过 max 个，多余执行将会加入队列，直到有Promise完成 */\nexport function queue<T, P extends any[], R>(f: (this: T, ...argv: P) => R | Promise<R>, max?: number): ((this: T, ...argv: P) => Promise<R>);\nexport function queue<T, P extends any[], R>(f: ((this: T, ...argv: P) => R | Promise<R>)[], max?: number): (((this: T, ...argv: P) => Promise<R>) | undefined)[];\nexport function queue<T, P extends any[], R>(\n\tf: ((this: T, ...argv: P) => R | Promise<R>) | ((this: T, ...argv: P) => R | Promise<R>)[],\n\tmax: number = 1\n): ((this: T, ...argv: P) => Promise<R>) | (((this: T, ...argv: P) => Promise<R>) | undefined)[] | undefined {\n\tconst queue: ((...p: any[]) => void)[] = [];\n\tlet wait: number = 0;\n\tfunction next(): void {\n\t\tif (queue.length) {\n\t\t\t(queue.shift() as ((...p: any[]) => void))();\n\t\t} else {\n\t\t\twait--;\n\t\t}\n\t}\n\tfunction getRunStatus(): Promise<void> {\n\t\treturn new Promise(r => wait < max ? r(void wait++) : queue.push(r));\n\t}\n\tfunction get(f: (this: T, ...argv: P) => R | Promise<R>): (this: T, ...argv: P) => Promise<R> {\n\t\treturn async function (this: T, ...argv: P): Promise<R> {\n\t\t\ttry {\n\t\t\t\tawait getRunStatus();\n\t\t\t\treturn await f.call(this, ...argv);\n\t\t\t} finally {\n\t\t\t\tnext();\n\t\t\t}\n\t\t}\n\t}\n\tif (typeof f === 'function') {\n\t\treturn get(f);\n\t} else if (Array.isArray(f)) {\n\t\treturn f.map(f => typeof f === 'function' ? undefined : get(f));\n\t}\n}\n/** 封装成忽略性执行，封装后函数永远返回Promise，确保同时执行的函数不超过 max 个，多余只保留最后一个，担有一个Promise完成，执行最后一次参数 */\nexport function ignore<T, P, R>(f: (this: T, ...argv: P[]) => R | Promise<R>, max: number = 1): (this: T, ...argv: P[]) => Promise<R> {\n\ttype PromiseBackCall = [(value?: R | PromiseLike<R>) => void, (reason?: any) => void];\n\ttype Param = [T, ...P[]];\n\tlet run: number = 0;\n\tlet next: Param | undefined;\n\tlet end: PromiseBackCall[] = [];\n\tfunction getEndFunc(): PromiseBackCall[] {\n\t\tlet e: PromiseBackCall[] = end;\n\t\tend = [];\n\t\treturn e;\n\t}\n\tfunction getNextParam() {\n\t\tlet p = next;\n\t\tnext = undefined;\n\t\treturn p;\n\t}\n\tfunction setNextParam(p: Param): void {\n\t\tnext = p;\n\t}\n\tasync function exec(p: Param) {\n\t\tif (run >= max) {\n\t\t\treturn setNextParam(p);\n\t\t}\n\t\trun++;\n\t\t//获取上次执行到现在缓存的结束函数\n\t\tconst end: PromiseBackCall[] = getEndFunc();\n\t\t//执行函数\n\t\tlet ret: R, error = false;\n\t\ttry {\n\t\t\tret = await f.call(...p);\n\t\t} catch (e) {\n\t\t\tret = e;\n\t\t\terror = true;\n\t\t}\n\t\t//返回函数\n\t\tfor (let f of end) {\n\t\t\tf[error ? 1 : 0](ret);\n\t\t}\n\t\trun--;\n\t\t//获取下一轮参数\n\t\tconst next: Param | undefined = getNextParam();\n\t\tif (next) {\n\t\t\treturn exec(next);\n\t\t}\n\t}\n\treturn async function (this: T, ...p: P[]) {\n\t\treturn new Promise((f1, f2) => {end.push([f1, f2]); exec([this, ...p]);});\n\t}\n}\n"],"file":"funcctrl.js"}